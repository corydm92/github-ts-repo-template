# CI Orchestration (Project + Apps)

This repo treats the **project root** as the orchestrator and each app under `/apps` as an independent unit.
CI runs on pull requests and executes:

1. **Project gates** (root-level checks)
2. **App gates** (only the apps that changed)
3. **Package gates** (only the packages that changed)

---

## How CI is triggered

Workflow: `.github/workflows/ci.yml`

- Trigger: `pull_request`
- Uses Node 24 + Corepack + pnpm from `packageManager`
- Installs dependencies once at the root
- Runs `pnpm run ci` with PR context:
  - `AFFECTED_MODE=pr`
  - `BASE_REF=${{ github.base_ref }}`
  - `HEAD_SHA=${{ github.sha }}`

---

## Project gate (root)

Root scripts (in `package.json`):

- `ci:project` → runs project-level checks
- `ci` → runs `ci:project` then `ci:apps`

Project checks are only meant for **repo-level files** (configs, workflows, etc).
They do **not** enforce app- or package-specific rules.
Project checks also validate the workspace contract (required scripts + cycle detection).

---

## App gate (per app)

App checks are delegated to each app’s own `ci` script.

- App `ci` is defined in `apps/<app>/package.json`
- App CI can vary by app (frontend/back/db/infra are not forced to match)

App CI is triggered via:

- `scripts/affected-apps.mjs` → detects which apps (and packages) changed
- `scripts/run-affected.mjs` → runs `pnpm -C apps/<app> run ci`

If an app changes but has no `ci` script, CI fails.

---

## Package gate (per package)

Package checks are delegated to each package’s own `ci` script.

- Package `ci` is defined in `packages/<pkg>/package.json`
- Package CI can vary by package

Package CI is triggered via:

- `scripts/affected-apps.mjs` → detects which packages changed
- `scripts/run-affected.mjs` → runs `pnpm -C packages/<pkg> run ci`

If a package changes but has no `ci` script, CI fails.

---

## Change detection rules

Change detection uses:

```
git diff --name-only origin/<BASE_REF>...<HEAD_SHA>
```

- Changes under `apps/<name>` → run only that app
- Changes under `packages/<name>` → run that package + dependent apps
- Non-package files under `packages/` are treated as shared changes
- Changes in shared config (root files, lockfiles, tooling) → run **all apps**

Shared config is defined in `scripts/affected-apps.mjs`.

---

## Local pre-commit behavior

Hook: `.husky/pre-commit`

```
AFFECTED_MODE=staged pnpm run ci
```

This runs the same orchestration locally but uses **staged files** to detect affected apps/packages.

---

## Add a new app

1. Create folder under `/apps/<app>`
2. Add `package.json` with a `ci` script
3. App CI will run automatically when files change

---

## Add a new package

1. Create folder under `/packages/<pkg>`
2. Add `package.json` with a `ci` script
3. Package CI will run automatically when files change

---

## Quick checks

From repo root:

- `pnpm run ci` → project + affected apps + affected packages
- `pnpm -C apps/<app> run ci` → just one app
- `pnpm -C packages/<pkg> run ci` → just one package

---

## CI Gate Reference (merged)

This repo uses a **project gate** + **app gate**.

### Project gate (root)

Runs via:

```
pnpm run ci:project
```

Purpose: enforce repo-level quality for shared config and tooling.

### App gate (per app)

Runs via:

```
pnpm run ci:apps
```

- Detects which apps changed
- Runs `pnpm -C apps/<app> run ci` for each affected app
- Fails if an affected app does not define a `ci` script

### Full gate

```
pnpm run ci
```

Runs project gate first, then app + package gates.
